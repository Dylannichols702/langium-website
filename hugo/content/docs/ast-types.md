---
title: "AST Type Inference"
weight: 200
---

When a grammar increases in complexity and maturity, it is common to want control over the types of the generated AST nodes. This reduces the risk of introducing breaking changes since any modification of the grammar may lead to a change in the generated types. Langium allows to define types directly into the language grammar by using a *TypeScript-like* syntax. In the following, we detail how types and their inference or declaration are handled by Langium.

There are two ways by which Langium generates types for the generated AST nodes:
* *[Inference](#inferred-types)*: types are inferred from the grammar and automatically generated by Langium.
* *[Declaration](#declared-types)*: types are declared explicitly in the grammar and fully controlled by the user.

## Inferred Types
*Inferred Types* are the default behavior in Langium. They are a powerful feature for simple DSLs and prototypes. The simplest way to write a parser rule is as follows:
```
X: name=ID;
```
With this syntax, Langium will **infer** the type of the AST node to be generated when parsing the rule. By convention, the type of the AST node will be named after the name of the rule, resulting in this **TypeScript's interface** in the AST:
```
export interface X extends AstNode {
    name: string
}
```
It is however possible to control the naming of the interface by using the following syntax:
```
X infers MyType: name=ID;
```
resulting in the following interface in the AST:
```
export interface MyType extends AstNode {
    name: string
}
```
Please note that `interface X` is no longer present in the AST.

It is important to understand that the name of the parser rule and the name of the type it infers work on two separate abstraction levels. The name of the parser rule is used in the *parsing layer* where types are ignored and only the parsing rule is considered, while the name of the type is used in the *types layer* where both the type and the parser rule play a role. This means that the name of the type can be changed without affecting the parsing of the rule, and that the name of the rule can be changed without affecting the AST.

By inferring types within the grammar, it is also possible to define several parser rules creating the same AST node type. For example, the following grammar has two rules `X` and `Y` inferring a single AST node type `MyType`:
```
X infers MyType: name=ID;
Y infers MyType: name=ID count=INT;
```
This result in the creation of a single interface in the AST 'merging' the two parser rules with non-common properties made optional:
```
export interface MyType extends AstNode {
    count?: number
    name: string
}
```

[Some parser rules](../grammar-language/#unassigned-rule-calls) do not create an object themselves but refer to other parsing rules that will create the object. For example, in the following grammar the parsing rule 'X' will result in an object of type 'A' or of type 'B' (or any type they may infer or return):
```
X: A | B;
```
results in the type-alias:
```
export type X = A | B;
```

[Data Type Rules](../grammar-language/#data-type-rules) are also inferred (even though they use the keyword `returns`) and result in a type alias:
```
QualifiedName returns string: ID '.' ID;

// generates:
export type QualifiedName = string;
```
## Declared Types
To gain full control over the properties of the generated interfaces, you can explicitly declare an interface directly in the grammar. This is the recommend way for mature and more complex DSLs since it introduces some level of safety inside the grammar. Let's declare MyType from the previous section directly in the language grammar:
```
interface MyType {
    name: string
    count?: number
}
```
The parser rules creating the AST node type `MyType` will also need to explicitly declare the type of the AST node they create with the `returns` keyword:
```
X returns MyType: name=ID;
Y returns MyType: name=ID count=INT;
```

Contrary to [inferred types](#inferred-types), all properties must be explicitly declared in order to be valid inside of a parser rule. The following syntax:
```
Z returns MyType: name=ID age=INT;
```
will throw the following validation error `A property 'age' is not expected` because the declaration of `MyType` does not include the property `age`. In short, *declared types* add a layer of validation to the grammar that prevent mismatches between the generated AST types and what the user expects.

However, a declared type can extend another type:
```
interface MyType {
    name: string
}

interface MyOtherType extends MyType {
    count: number
}

Y returns MyOtherType: name=ID count=INT;
```

Explicitly declaring type aliases in the grammar is achieved with the keyword `type`:
```
type X = A | B;

// generates
export type X = A | B;
```
Please note that it is not allowed to use an alias type as a return type in a parser rule:
```
type X = A | B;

Y returns X: name=ID;
```

Using `returns` without explicitly declaring the type of the AST node is not allowed and results in a validation error.

## Refactoring Dummy Rules
*Dummy rules* are parser rules that are not reachable from the entry rule of the grammar. Despite the fact that they do not participate in the parsing process, they play a key role in shaping the AST. They infer types in the same fashion as any other parser rule with type inference. However, dummy rules are exempt from validation check and for the sake of safety should be replaced by declared types.

Let's look at two dummy rules:
```
X : A | B;

Y: name=ID;
```
The first one is inferring a type alias, and the second one an interface
```
export type X = A | B;

export interface Y extends AstNode {
    name: string
}
```
They can be declared in the grammar as:
```
type X = A | B;

interface Y {
    name: string
}
```

## Controlling the AST with Actions
The AST node types can also be controlled through [actions](../grammar-language/#simple-actions). Actions can be used to improve the readability of more complex grammar and can use both inferred and declared type.

In the following grammar:
```
X: {A} 'A' name=ID | {infer B} 'B' name=ID;
```
`{A}` and `{infer B}` are both actions. The first one uses the declared type 'A' (which needs to be explicitly declared in the grammar), while the second one infers the type 'B'. The parser rule 'X' generates an AST node of type `A` if the keyword 'A' is consumed and an AST node of type `B` if the keyword 'B' is consumed.

Actions can also be used to guide the structure of an AST node as described [here](../grammar-language/#tree-rewriting-actions). Following the same example, we first take a look at the parser rule 'Addition' without the use of action: 
```
Addition:
    SimpleExpression ('+' right=SimpleExpression)*;

SimpleExpression:
    '(' Addition ')' | value=INT;

// generates:
export interface Addition extends SimpleExpression {
    readonly $container: Addition;
    right: SimpleExpression
}

export interface SimpleExpression extends Addition {
    readonly $container: Addition;
    value: number
}
```

```
Addition returns Addition:
    SimpleExpression ({infer Addition.left=current} '+' right=SimpleExpression)*;

SimpleExpression: 
    '(' Addition ')' | value=INT;

// generates:
export interface Addition extends SimpleExpression {
    readonly $container: Addition;
    left: SimpleExpression
    right: SimpleExpression
}
export interface SimpleExpression extends Addition {
    readonly $container: Addition;
    value: number
}
```
